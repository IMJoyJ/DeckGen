using System;
using System.Collections.Generic;
using System.Data.SQLite;
using System.IO;
using System.Linq;

namespace DeckGen
{
    class Program
    {
        public const long   TYPE_FUSION         = 0x40      ;
        public const long   TYPE_SYNCHRO        = 0x2000    ;
        public const long   TYPE_XYZ            = 0x800000  ;
        public const long   TYPE_LINK           = 0x4000000 ;
        static void Main(string[] args)
        {
            if (args.Length < 6)
            {
                Console.WriteLine("Usage:");
                Console.WriteLine("deckgen [cdb file] [lflist file] [num of main] [num of ex] [num of side] [how many deck should be generated]");
                Console.WriteLine("e.g. deckgen cards.cdb lflist.conf 40 15 15 100");
                return;
            }
            string cdbFile = args[0];
            string lfListFile = args[1];
            string numOfMain = args[2];
            string numOfEx = args[3];
            string numOfSide = args[4];
            int deckNum = int.Parse(args[5]);
            Console.WriteLine("Reading lflist...");
            ReadLfList(lfListFile);
            Console.WriteLine("Initialize card pool...");
            //There are only about 10K*3 cards for now(<300KB when use string). A initialize should be a better way.
            InitCardPool(cdbFile);

            Console.WriteLine("Generating decks...");
            int percent = 0;
            Directory.CreateDirectory("decks");
            for(int i = 0; i < deckNum; i++)
            {
                if (!GenerateDeck(int.Parse(numOfMain), int.Parse(numOfEx), int.Parse(numOfSide),$"decks{Path.DirectorySeparatorChar}output{i}.ydk"))
                {
                    break;
                }
                if (i * 100 / deckNum >= (percent + 10) / 10 * 10)
                {
                    percent = i * 100 / deckNum / 10 * 10;
                    Console.WriteLine($"Completed {percent}%");
                }
            }
            Console.WriteLine($"Completed 100%, generating new lflist...");
            GenerateCardPoolLFList();
            Console.WriteLine($"Completed!Press any key to exit.");
            Console.ReadKey();
        }

        private static void GenerateCardPoolLFList()
        {
            FileStream fs = new FileStream("new-lflist.conf",FileMode.Create);
            StreamWriter sw = new StreamWriter(fs);
            sw.WriteLine("#Generated by DeckGen");
            sw.WriteLine("#!Special");
            sw.WriteLine("#forbidden");
            foreach (string card in (from kvp in CardPoolLFList
                                     where kvp.Value == 0
                                     select kvp.Key))
            {
                sw.WriteLine($"{card} 0");
            }
            sw.WriteLine("#limit");
            foreach (string card in (from kvp in CardPoolLFList
                                     where kvp.Value == 1
                                     select kvp.Key))
            {
                sw.WriteLine($"{card} 1");
            }
            sw.WriteLine("#semi limit");
            foreach (string card in (from kvp in CardPoolLFList
                                     where kvp.Value == 2
                                     select kvp.Key))
            {
                sw.WriteLine($"{card} 2");
            }
        }

        private static void InitCardPool(string cdbFile)
        {
            SQLiteConnection sqlcon = new SQLiteConnection($"Data Source={cdbFile}");
            sqlcon.Open();
            SQLiteCommand cmd = new SQLiteCommand("SELECT id,type FROM datas", sqlcon);
            var reader = cmd.ExecuteReader();
            while(reader.Read())
            {
                string id = reader["id"].ToString();
                long type = (long)reader["type"];
                int num = 3;
                CardPoolLFList.Add(id, 0);
                if (LFList.ContainsKey(id))
                {
                    num = LFList[id];
                }
                if (((type & TYPE_FUSION) > 0) || ((type & TYPE_XYZ) > 0)
                    || ((type & TYPE_LINK) > 0) || ((type & TYPE_SYNCHRO) > 0))
                {
                    for (int i = 0; i < num; i++)
                    {
                        CardPoolEx.Add(id);
                    }
                }
                else
                {
                    for (int i = 0; i < num; i++)
                    {
                        CardPool.Add(id);
                    }
                }
            }
            reader.Close();
            cmd.Dispose();
            sqlcon.Dispose();
        }

        static readonly Random _rd = new Random();
        private static bool GenerateDeck(int numOfMain, int numOfEx, int numOfSide, string file)
        {
            Dictionary<string,int> main = new Dictionary<string, int>();
            Dictionary<string,int> ex = new Dictionary<string, int>();
            Dictionary<string,int> side = new Dictionary<string, int>();
            for (int i = 0; i < numOfMain; i++)
            {
                if(CardPool.Count == 0)
                {
                    break;
                }
                int index = _rd.Next(CardPool.Count);
                if (main.ContainsKey(CardPool[index]))
                {
                    main[CardPool[index]]++;
                }
                else
                {
                    main.Add(CardPool[index], 1);
                }
                CardPool.RemoveAt(index);
            }
            for (int i = 0; i < numOfEx; i++)
            {
                if (CardPoolEx.Count == 0)
                {
                    break;
                }
                int index = _rd.Next(CardPoolEx.Count);
                if (ex.ContainsKey(CardPoolEx[index]))
                {
                    ex[CardPoolEx[index]]++;
                }
                else
                {
                    ex.Add(CardPoolEx[index], 1);
                }
                CardPoolEx.RemoveAt(index);
            }
            for (int i = 0; i < numOfSide; i++)
            {
                if (CardPoolEx.Count == 0 && CardPool.Count == 0)
                {
                    break;
                }
                int index = _rd.Next(CardPoolEx.Count + CardPool.Count);
                if (index >= CardPoolEx.Count)
                {
                    index -= CardPoolEx.Count;
                    if (side.ContainsKey(CardPool[index]))
                    {
                        side[CardPoolEx[index]]++;
                    }
                    else
                    {
                        side.Add(CardPool[index], 1);
                    }
                    CardPool.RemoveAt(index);
                }
                else
                {
                    if (side.ContainsKey(CardPoolEx[index]))
                    {
                        side[CardPoolEx[index]]++;
                    }
                    else
                    {
                        side.Add(CardPoolEx[index], 1);
                    }
                    CardPoolEx.RemoveAt(index);
                }
            }
            if (main.Count == 0 && ex.Count == 0 && side.Count == 0)
            {
                return false;
            }
            Dictionary<string, int> allDeck = new Dictionary<string, int>();
            foreach (var kvp in main)
            {
                allDeck.Add(kvp.Key, kvp.Value);
            }
            foreach (var kvp in ex)
            {
                if (allDeck.ContainsKey(kvp.Key))
                {
                    allDeck[kvp.Key] += kvp.Value;
                }
                else
                {
                    allDeck.Add(kvp.Key, kvp.Value);
                }
            }
            foreach (var kvp in side)
            {
                if (allDeck.ContainsKey(kvp.Key))
                {
                    allDeck[kvp.Key] += kvp.Value;
                }
                else
                {
                    allDeck.Add(kvp.Key, kvp.Value);
                }
            }
            foreach (var kvp in allDeck)
            {
                CardPoolLFList[kvp.Key] = Math.Max(CardPoolLFList[kvp.Key], kvp.Value);
            }
            FileStream fs = new FileStream(file,FileMode.Create);
            StreamWriter sw = new StreamWriter(fs);
            sw.WriteLine("#created by DeckGen");
            sw.WriteLine("#main");
            foreach(var kvp in main)
            {
                for(int i = 0; i < kvp.Value; i++)
                {
                    sw.WriteLine(kvp.Key);
                }
            }
            sw.WriteLine("#extra");
            foreach (var kvp in ex)
            {
                for (int i = 0; i < kvp.Value; i++)
                {
                    sw.WriteLine(kvp.Key);
                }
            }
            sw.WriteLine("!side");
            foreach (var kvp in side)
            {
                for (int i = 0; i < kvp.Value; i++)
                {
                    sw.WriteLine(kvp.Key);
                }
            }
            sw.Close();
            fs.Close();
            main.Clear();
            ex.Clear();
            side.Clear();
            return true;
        }


        public static Dictionary<string,int> LFList = new Dictionary<string, int>();
        public static List<string> CardPool = new List<string>();
        public static List<string> CardPoolEx = new List<string>();
        public static Dictionary<string,int> CardPoolLFList = new Dictionary<string, int>();
        private static void ReadLfList(string file)
        {
            FileStream fs = File.OpenRead(file);
            StreamReader sr = new StreamReader(fs);
            bool reading = false;
            for (string line = sr.ReadLine(); line != null; line = sr.ReadLine())
            {
                line = line.Trim();
                if (line.StartsWith("#"))
                {
                    continue;
                }
                if (line.StartsWith("!"))
                {
                    if (reading)
                    {
                        break;
                    }
                    reading = true;
                    continue;
                }
                if (line.Contains("--"))
                {
                    line = line.Substring(0, line.IndexOf("--"));
                    line = line.Trim();
                }
                string[] split = line.Split(' ');
                if (split.Length < 2)
                {
                    continue;
                }
                LFList.Add(split[0], int.Parse(split[1]));
            }
        }
    }
}
